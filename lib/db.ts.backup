// lib/db.ts
import { neon } from '@neondatabase/serverless';

/**
 * Get a new database connection.
 * Call this INSIDE your route handlers, not at the top level.
 */
export function getDbConnection() {
  return neon(process.env.DATABASE_URL!);
}

/**
 * Execute a query and return all rows.
 * Usage: const rows = await query('SELECT * FROM users WHERE id = $1', [userId]);
 */
export async function query<T = any>(sqlText: string, params: any[] = []): Promise<T[]> {
  const sql = neon(process.env.DATABASE_URL!);
  // Using tagged template literal. For parameterized queries, you might need to adjust.
  // This example uses the sql`` tagged template. If you need parameterized style, use sql(sqlText, params)
  return sql(sqlText, params) as Promise<T[]>;
}

/**
 * Execute a query and return the first row, or null.
 * Usage: const user = await queryOne('SELECT * FROM users WHERE id = $1', [userId]);
 */
export async function queryOne<T = any>(sqlText: string, params: any[] = []): Promise<T | null> {
  const rows = await query<T>(sqlText, params);
  return rows[0] || null;
}
// lib/db.ts
import { sql } from 'kysely'; // or your database library

// If using kysely:
export { sql };

// Or if using a different setup:
export const sql = /* your sql instance */;

/**
 * Execute a series of queries in a transaction.
 * Usage: await transaction(async (sql) => { ... });
 */
export async function transaction<T>(
  callback: (sql: any) => Promise<T>
): Promise<T> {
  const sql = neon(process.env.DATABASE_URL!);
  // Note: The Neon serverless driver might handle transactions differently.
  // This is a basic example. You might need to use `sql.begin()` for proper transactions.
  return callback(sql);
}

// Re-export neon for direct use if needed
export { neon };
